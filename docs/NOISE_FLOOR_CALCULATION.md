# Noise Floor Calculation Documentation

## Overview

The FGCom-mumble Noise Floor Calculation system provides advanced atmospheric noise modeling with environment-specific calculations, distance-based noise falloff, and manual position setting via GPS or Maidenhead locators. This system simulates realistic noise conditions that affect radio communication quality.

## What is Noise Floor?

The noise floor is the minimum level of background noise present in a radio communication system. It represents the lowest signal level that can be detected above the ambient noise. The noise floor is influenced by:

- **Atmospheric Noise**: Natural atmospheric phenomena (lightning, solar activity)
- **Man-made Noise**: Electrical equipment, power lines, industrial sources
- **Thermal Noise**: Random thermal motion of electrons in conductors
- **Receiver Noise**: Internal noise generated by the receiver itself
- **Environmental Factors**: Terrain, vegetation, buildings, weather conditions

## System Architecture

### Core Components

- **NoiseFloorCalculator**: Main noise floor calculation system
- **AtmosphericNoiseModeler**: Atmospheric noise modeling
- **EnvironmentalNoiseModeler**: Environment-specific noise modeling
- **DistanceBasedNoiseModeler**: Distance-based noise falloff
- **PositionManager**: GPS and Maidenhead locator management
- **NoiseSpectrumAnalyzer**: Noise spectrum analysis

## Noise Sources and Modeling

### Atmospheric Noise

#### Natural Sources
- **Lightning**: Primary source of atmospheric noise
- **Solar Activity**: Solar flares and sunspots
- **Cosmic Noise**: Background radiation from space
- **Auroral Activity**: Polar aurora effects
- **Meteor Trails**: Meteor ionization effects

#### Modeling Parameters
- **Lightning Activity**: Strikes per minute, intensity, distance
- **Solar Flux**: 10.7 cm solar flux index
- **Geomagnetic Activity**: K-index, A-index
- **Time of Day**: Diurnal variations
- **Seasonal Effects**: Seasonal variations
- **Geographic Location**: Latitude-dependent effects

### Man-made Noise

#### Urban Sources
- **Power Lines**: 50/60 Hz harmonics
- **Industrial Equipment**: Motors, generators, transformers
- **Transportation**: Vehicles, aircraft, trains
- **Communication Systems**: Cell towers, WiFi, Bluetooth
- **Electronic Devices**: Computers, appliances, lighting

#### Rural Sources
- **Power Lines**: High-voltage transmission lines
- **Agricultural Equipment**: Irrigation systems, machinery
- **Communication Towers**: Radio, TV, cellular
- **Wind Turbines**: Electrical noise from generators

### Environmental Factors

#### Terrain Effects
- **Mountains**: Signal reflection and multipath
- **Valleys**: Signal trapping and focusing
- **Water Bodies**: Signal reflection and absorption
- **Urban Areas**: Building reflection and absorption
- **Forests**: Signal absorption and scattering

#### Weather Effects
- **Precipitation**: Rain, snow, hail absorption
- **Temperature**: Atmospheric refraction
- **Humidity**: Signal absorption
- **Wind**: Atmospheric turbulence
- **Pressure**: Atmospheric density changes

## Configuration

### Noise Floor Configuration

```ini
# configs/noise_floor.conf
[noise_floor]
# Enable/disable noise floor calculation
enabled = true

# Atmospheric noise modeling
enable_atmospheric_noise = true
enable_lightning_noise = true
enable_solar_noise = true
enable_cosmic_noise = true
enable_auroral_noise = true

# Man-made noise modeling
enable_urban_noise = true
enable_industrial_noise = true
enable_transportation_noise = true
enable_communication_noise = true

# Environmental noise modeling
enable_terrain_noise = true
enable_weather_noise = true
enable_vegetation_noise = true
enable_building_noise = true

# Distance-based modeling
enable_distance_falloff = true
falloff_exponent = 2.0
min_distance_km = 0.1
max_distance_km = 1000.0

# Position management
enable_gps_positioning = true
enable_maidenhead_positioning = true
position_update_interval_seconds = 60
position_accuracy_threshold_m = 100.0

# Noise spectrum analysis
enable_spectrum_analysis = true
frequency_resolution_hz = 1000.0
spectrum_bands = ["VLF", "LF", "MF", "HF", "VHF", "UHF", "SHF", "EHF"]

# Caching
enable_noise_caching = true
cache_duration_hours = 24
max_cache_size_mb = 1000
cache_cleanup_interval_hours = 6
```

## Data Structures

### Noise Floor Status

```cpp
struct fgcom_noise_floor_status {
    // Current noise floor
    float current_noise_floor_db;
    float atmospheric_noise_db;
    float man_made_noise_db;
    float environmental_noise_db;
    float thermal_noise_db;
    float receiver_noise_db;
    
    // Noise sources
    float lightning_noise_db;
    float solar_noise_db;
    float cosmic_noise_db;
    float auroral_noise_db;
    float urban_noise_db;
    float industrial_noise_db;
    float transportation_noise_db;
    float communication_noise_db;
    
    // Environmental factors
    float terrain_noise_db;
    float weather_noise_db;
    float vegetation_noise_db;
    float building_noise_db;
    
    // Distance effects
    float distance_falloff_db;
    float nearest_source_distance_km;
    float dominant_noise_source;
    
    // Frequency characteristics
    std::map<std::string, float> band_noise_floor; // Frequency band -> Noise floor
    std::map<float, float> noise_spectrum; // Frequency -> Noise level
    float dominant_noise_frequency_hz;
    float noise_bandwidth_hz;
    
    // Position information
    double latitude;
    double longitude;
    float altitude_m;
    std::string maidenhead_locator;
    std::string environment_type; // "urban", "suburban", "rural", "remote"
    
    // Timestamps
    std::chrono::system_clock::time_point timestamp;
    std::chrono::system_clock::time_point last_update;
    
    // Status flags
    bool noise_floor_enabled;
    bool atmospheric_noise_enabled;
    bool man_made_noise_enabled;
    bool environmental_noise_enabled;
    bool distance_falloff_enabled;
    bool position_tracking_enabled;
};
```

### Noise Source Structure

```cpp
struct fgcom_noise_source {
    std::string source_id;
    std::string source_type; // "lightning", "industrial", "transportation", etc.
    double latitude;
    double longitude;
    float altitude_m;
    float intensity_db;
    float frequency_hz;
    float bandwidth_hz;
    float distance_km;
    float bearing_deg;
    std::chrono::system_clock::time_point timestamp;
    bool active;
    float confidence_score;
};
```

## API Endpoints

### Noise Floor Status

#### Get Noise Floor Status
```http
GET /api/v1/noise-floor/status
Authorization: Bearer your_jwt_token_here
```

**Response:**
```json
{
  "success": true,
  "noise_floor_status": {
    "current_noise_floor_db": -95.0,
    "atmospheric_noise_db": -98.0,
    "man_made_noise_db": -102.0,
    "environmental_noise_db": -105.0,
    "thermal_noise_db": -110.0,
    "receiver_noise_db": -115.0,
    "lightning_noise_db": -100.0,
    "solar_noise_db": -105.0,
    "cosmic_noise_db": -108.0,
    "auroral_noise_db": -110.0,
    "urban_noise_db": -95.0,
    "industrial_noise_db": -98.0,
    "transportation_noise_db": -102.0,
    "communication_noise_db": -105.0,
    "terrain_noise_db": -108.0,
    "weather_noise_db": -110.0,
    "vegetation_noise_db": -112.0,
    "building_noise_db": -115.0,
    "distance_falloff_db": -5.0,
    "nearest_source_distance_km": 2.5,
    "dominant_noise_source": "urban",
    "band_noise_floor": {
      "VLF": -110.0,
      "LF": -105.0,
      "MF": -100.0,
      "HF": -95.0,
      "VHF": -90.0,
      "UHF": -85.0,
      "SHF": -80.0,
      "EHF": -75.0
    },
    "noise_spectrum": {
      "1000000": -95.0,
      "10000000": -90.0,
      "100000000": -85.0,
      "1000000000": -80.0
    },
    "dominant_noise_frequency_hz": 1000000.0,
    "noise_bandwidth_hz": 1000000.0,
    "latitude": 40.7128,
    "longitude": -74.0060,
    "altitude_m": 100.0,
    "maidenhead_locator": "FN20",
    "environment_type": "urban",
    "noise_floor_enabled": true,
    "atmospheric_noise_enabled": true,
    "man_made_noise_enabled": true,
    "environmental_noise_enabled": true,
    "distance_falloff_enabled": true,
    "position_tracking_enabled": true,
    "timestamp": "2024-01-15T10:30:00Z"
  }
}
```

#### Get Noise Sources
```http
GET /api/v1/noise-floor/sources
Authorization: Bearer your_jwt_token_here
```

**Query Parameters:**
- `radius_km` (optional): Search radius in kilometers (default: 100)
- `source_type` (optional): Filter by source type
- `min_intensity_db` (optional): Minimum intensity in dB (default: -120.0)

**Response:**
```json
{
  "success": true,
  "sources": [
    {
      "source_id": "source_001",
      "source_type": "industrial",
      "latitude": 40.7128,
      "longitude": -74.0060,
      "altitude_m": 50.0,
      "intensity_db": -95.0,
      "frequency_hz": 1000000.0,
      "bandwidth_hz": 100000.0,
      "distance_km": 2.5,
      "bearing_deg": 45.0,
      "timestamp": "2024-01-15T10:30:00Z",
      "active": true,
      "confidence_score": 0.95
    }
  ],
  "total_sources": 1,
  "search_radius_km": 100.0
}
```

### Position Management

#### Set Position via GPS
```http
POST /api/v1/noise-floor/position/gps
Authorization: Bearer your_jwt_token_here
Content-Type: application/json
```

**Request:**
```json
{
  "latitude": 40.7128,
  "longitude": -74.0060,
  "altitude_m": 100.0,
  "accuracy_m": 10.0,
  "timestamp": "2024-01-15T10:30:00Z"
}
```

**Response:**
```json
{
  "success": true,
  "message": "Position updated successfully",
  "position": {
    "latitude": 40.7128,
    "longitude": -74.0060,
    "altitude_m": 100.0,
    "maidenhead_locator": "FN20",
    "environment_type": "urban",
    "noise_floor_db": -95.0,
    "timestamp": "2024-01-15T10:30:00Z"
  }
}
```

#### Set Position via Maidenhead Locator
```http
POST /api/v1/noise-floor/position/maidenhead
Authorization: Bearer your_jwt_token_here
Content-Type: application/json
```

**Request:**
```json
{
  "maidenhead_locator": "FN20",
  "altitude_m": 100.0,
  "timestamp": "2024-01-15T10:30:00Z"
}
```

**Response:**
```json
{
  "success": true,
  "message": "Position updated successfully",
  "position": {
    "latitude": 40.7128,
    "longitude": -74.0060,
    "altitude_m": 100.0,
    "maidenhead_locator": "FN20",
    "environment_type": "urban",
    "noise_floor_db": -95.0,
    "timestamp": "2024-01-15T10:30:00Z"
  }
}
```

### Noise Floor Control

#### Set Noise Floor Parameters
```http
POST /api/v1/noise-floor/configure
Authorization: Bearer your_jwt_token_here
Content-Type: application/json
```

**Request:**
```json
{
  "enable_noise_floor": true,
  "enable_atmospheric_noise": true,
  "enable_man_made_noise": true,
  "enable_environmental_noise": true,
  "enable_distance_falloff": true,
  "falloff_exponent": 2.0,
  "min_distance_km": 0.1,
  "max_distance_km": 1000.0,
  "frequency_bands": ["HF", "VHF", "UHF"],
  "environment_type": "urban"
}
```

**Response:**
```json
{
  "success": true,
  "message": "Noise floor parameters configured",
  "noise_floor_enabled": true,
  "estimated_noise_floor_db": -95.0,
  "environment_type": "urban",
  "timestamp": "2024-01-15T10:30:00Z"
}
```

## C++ API Usage

### Basic Noise Floor Access

```cpp
#include "noise_floor.h"

// Get noise floor calculator instance
auto& noise_calculator = FGCom_NoiseFloorCalculator::getInstance();

// Get current noise floor status
fgcom_noise_floor_status status = noise_calculator.getNoiseFloorStatus();
std::cout << "Current noise floor: " << status.current_noise_floor_db << " dB" << std::endl;
std::cout << "Atmospheric noise: " << status.atmospheric_noise_db << " dB" << std::endl;
std::cout << "Man-made noise: " << status.man_made_noise_db << " dB" << std::endl;
```

### Set Position

```cpp
// Set position via GPS coordinates
double latitude = 40.7128;
double longitude = -74.0060;
float altitude = 100.0f;

bool success = noise_calculator.setPosition(latitude, longitude, altitude);
if (success) {
    std::cout << "Position set successfully" << std::endl;
}

// Set position via Maidenhead locator
std::string maidenhead = "FN20";
success = noise_calculator.setPositionMaidenhead(maidenhead, altitude);
if (success) {
    std::cout << "Position set via Maidenhead locator" << std::endl;
}
```

### Calculate Noise Floor

```cpp
// Calculate noise floor for specific frequency
float frequency_hz = 100000000.0f; // 100 MHz
float noise_floor = noise_calculator.calculateNoiseFloor(frequency_hz);
std::cout << "Noise floor at " << frequency_hz << " Hz: " << noise_floor << " dB" << std::endl;

// Get noise spectrum
auto noise_spectrum = noise_calculator.getNoiseSpectrum();
for (const auto& freq_noise : noise_spectrum) {
    std::cout << "Frequency: " << freq_noise.first << " Hz, Noise: " << freq_noise.second << " dB" << std::endl;
}
```

### Get Noise Sources

```cpp
// Get noise sources within 100km
std::vector<fgcom_noise_source> sources = noise_calculator.getNoiseSources(100.0f);

for (const auto& source : sources) {
    std::cout << "Source: " << source.source_type << std::endl;
    std::cout << "Location: " << source.latitude << ", " << source.longitude << std::endl;
    std::cout << "Intensity: " << source.intensity_db << " dB" << std::endl;
    std::cout << "Distance: " << source.distance_km << " km" << std::endl;
}
```

## Advanced Features

### Atmospheric Noise Modeling

```cpp
class AtmosphericNoiseModeler {
private:
    float base_atmospheric_noise_db;
    float lightning_noise_factor;
    float solar_noise_factor;
    float cosmic_noise_factor;
    float auroral_noise_factor;
    
public:
    float calculateAtmosphericNoise(float frequency_hz,
                                   float latitude,
                                   float longitude,
                                   const fgcom_weather_conditions& weather) {
        float total_noise = base_atmospheric_noise_db;
        
        // Lightning noise
        float lightning_noise = calculateLightningNoise(frequency_hz, latitude, longitude);
        total_noise += lightning_noise;
        
        // Solar noise
        float solar_noise = calculateSolarNoise(frequency_hz, latitude, longitude);
        total_noise += solar_noise;
        
        // Cosmic noise
        float cosmic_noise = calculateCosmicNoise(frequency_hz, latitude, longitude);
        total_noise += cosmic_noise;
        
        // Auroral noise
        float auroral_noise = calculateAuroralNoise(frequency_hz, latitude, longitude);
        total_noise += auroral_noise;
        
        return total_noise;
    }
    
private:
    float calculateLightningNoise(float frequency_hz, float latitude, float longitude) {
        // Calculate lightning noise based on frequency and location
        float frequency_factor = -10.0f * log10(frequency_hz / 1000000.0f);
        float latitude_factor = (90.0f - abs(latitude)) / 90.0f;
        
        return lightning_noise_factor * frequency_factor * latitude_factor;
    }
    
    float calculateSolarNoise(float frequency_hz, float latitude, float longitude) {
        // Calculate solar noise based on frequency and location
        float frequency_factor = -5.0f * log10(frequency_hz / 1000000.0f);
        float latitude_factor = (90.0f - abs(latitude)) / 90.0f;
        
        return solar_noise_factor * frequency_factor * latitude_factor;
    }
    
    float calculateCosmicNoise(float frequency_hz, float latitude, float longitude) {
        // Calculate cosmic noise based on frequency and location
        float frequency_factor = -15.0f * log10(frequency_hz / 1000000.0f);
        float latitude_factor = (90.0f - abs(latitude)) / 90.0f;
        
        return cosmic_noise_factor * frequency_factor * latitude_factor;
    }
    
    float calculateAuroralNoise(float frequency_hz, float latitude, float longitude) {
        // Calculate auroral noise based on frequency and location
        float frequency_factor = -8.0f * log10(frequency_hz / 1000000.0f);
        float latitude_factor = (90.0f - abs(latitude)) / 90.0f;
        
        return auroral_noise_factor * frequency_factor * latitude_factor;
    }
};
```

### Man-made Noise Modeling

```cpp
class ManMadeNoiseModeler {
private:
    float base_urban_noise_db;
    float base_industrial_noise_db;
    float base_transportation_noise_db;
    float base_communication_noise_db;
    
public:
    float calculateManMadeNoise(float frequency_hz,
                               const std::string& environment_type,
                               const std::vector<fgcom_noise_source>& sources) {
        float total_noise = 0.0f;
        
        // Environment-based noise
        if (environment_type == "urban") {
            total_noise += calculateUrbanNoise(frequency_hz);
        } else if (environment_type == "suburban") {
            total_noise += calculateSuburbanNoise(frequency_hz);
        } else if (environment_type == "rural") {
            total_noise += calculateRuralNoise(frequency_hz);
        } else if (environment_type == "remote") {
            total_noise += calculateRemoteNoise(frequency_hz);
        }
        
        // Source-based noise
        for (const auto& source : sources) {
            float source_noise = calculateSourceNoise(frequency_hz, source);
            total_noise += source_noise;
        }
        
        return total_noise;
    }
    
private:
    float calculateUrbanNoise(float frequency_hz) {
        // Calculate urban noise based on frequency
        float frequency_factor = -5.0f * log10(frequency_hz / 1000000.0f);
        return base_urban_noise_db + frequency_factor;
    }
    
    float calculateSuburbanNoise(float frequency_hz) {
        // Calculate suburban noise based on frequency
        float frequency_factor = -8.0f * log10(frequency_hz / 1000000.0f);
        return base_urban_noise_db - 10.0f + frequency_factor;
    }
    
    float calculateRuralNoise(float frequency_hz) {
        // Calculate rural noise based on frequency
        float frequency_factor = -12.0f * log10(frequency_hz / 1000000.0f);
        return base_urban_noise_db - 20.0f + frequency_factor;
    }
    
    float calculateRemoteNoise(float frequency_hz) {
        // Calculate remote noise based on frequency
        float frequency_factor = -15.0f * log10(frequency_hz / 1000000.0f);
        return base_urban_noise_db - 30.0f + frequency_factor;
    }
    
    float calculateSourceNoise(float frequency_hz, const fgcom_noise_source& source) {
        // Calculate noise from specific source
        float distance_factor = -20.0f * log10(source.distance_km);
        float frequency_factor = -10.0f * log10(frequency_hz / source.frequency_hz);
        
        return source.intensity_db + distance_factor + frequency_factor;
    }
};
```

### Distance-based Noise Falloff

```cpp
class DistanceBasedNoiseModeler {
private:
    float falloff_exponent;
    float min_distance_km;
    float max_distance_km;
    
public:
    float calculateDistanceFalloff(float distance_km, float base_noise_db) {
        if (distance_km < min_distance_km) {
            distance_km = min_distance_km;
        } else if (distance_km > max_distance_km) {
            distance_km = max_distance_km;
        }
        
        // Calculate distance-based falloff
        float falloff_db = -20.0f * falloff_exponent * log10(distance_km);
        return base_noise_db + falloff_db;
    }
    
    float calculateNoiseAtDistance(float source_noise_db,
                                  float source_distance_km,
                                  float target_distance_km) {
        // Calculate noise at target distance from source
        float distance_ratio = target_distance_km / source_distance_km;
        float falloff_db = -20.0f * falloff_exponent * log10(distance_ratio);
        
        return source_noise_db + falloff_db;
    }
};
```

### Position Management

```cpp
class PositionManager {
private:
    double current_latitude;
    double current_longitude;
    float current_altitude_m;
    std::string current_maidenhead_locator;
    std::string current_environment_type;
    
public:
    bool setPosition(double latitude, double longitude, float altitude_m) {
        // Validate coordinates
        if (latitude < -90.0 || latitude > 90.0 || longitude < -180.0 || longitude > 180.0) {
            return false;
        }
        
        current_latitude = latitude;
        current_longitude = longitude;
        current_altitude_m = altitude_m;
        
        // Convert to Maidenhead locator
        current_maidenhead_locator = convertToMaidenhead(latitude, longitude);
        
        // Determine environment type
        current_environment_type = determineEnvironmentType(latitude, longitude);
        
        return true;
    }
    
    bool setPositionMaidenhead(const std::string& maidenhead_locator, float altitude_m) {
        // Convert Maidenhead locator to coordinates
        auto coords = convertFromMaidenhead(maidenhead_locator);
        if (!coords.first || !coords.second) {
            return false;
        }
        
        return setPosition(coords.first, coords.second, altitude_m);
    }
    
private:
    std::string convertToMaidenhead(double latitude, double longitude) {
        // Convert coordinates to Maidenhead locator
        // Implementation details...
        return "FN20"; // Placeholder
    }
    
    std::pair<double, double> convertFromMaidenhead(const std::string& maidenhead_locator) {
        // Convert Maidenhead locator to coordinates
        // Implementation details...
        return {40.7128, -74.0060}; // Placeholder
    }
    
    std::string determineEnvironmentType(double latitude, double longitude) {
        // Determine environment type based on location
        // This would typically use geographic databases
        return "urban"; // Placeholder
    }
};
```

## Performance Optimization

### Noise Caching

```cpp
class NoiseFloorCache {
private:
    std::map<std::string, fgcom_noise_floor_status> cache;
    std::mutex cache_mutex;
    std::time_t cache_ttl;
    
public:
    bool getCachedNoiseFloor(const std::string& key, fgcom_noise_floor_status& status) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        
        auto it = cache.find(key);
        if (it != cache.end()) {
            // Check if data is still valid
            auto now = std::chrono::system_clock::now();
            auto age = std::chrono::duration_cast<std::chrono::seconds>(
                now - it->second.timestamp).count();
            
            if (age < cache_ttl) {
                status = it->second;
                return true;
            } else {
                // Remove expired data
                cache.erase(it);
            }
        }
        
        return false;
    }
    
    void setCachedNoiseFloor(const std::string& key, const fgcom_noise_floor_status& status) {
        std::lock_guard<std::mutex> lock(cache_mutex);
        cache[key] = status;
    }
};
```

## Error Handling

### Common Error Responses

```json
{
  "success": false,
  "error": {
    "code": "INVALID_POSITION",
    "message": "Invalid position coordinates provided",
    "details": {
      "latitude": 200.0,
      "longitude": -74.0060,
      "valid_latitude_range": "-90.0 to 90.0",
      "valid_longitude_range": "-180.0 to 180.0"
    }
  },
  "timestamp": "2024-01-15T10:30:00Z"
}
```

### Error Codes

- **INVALID_POSITION**: Invalid position coordinates
- **NOISE_CALCULATION_FAILED**: Noise floor calculation failed
- **POSITION_UPDATE_FAILED**: Position update failed
- **CACHE_OPERATION_FAILED**: Noise floor cache operation failed
- **ENVIRONMENT_DETECTION_FAILED**: Environment type detection failed
- **DISTANCE_CALCULATION_FAILED**: Distance calculation failed

## WebSocket Real-time Updates

### Noise Floor Updates

```json
{
  "type": "noise_floor_update",
  "timestamp": "2024-01-15T10:30:00Z",
  "data": {
    "current_noise_floor_db": -95.0,
    "atmospheric_noise_db": -98.0,
    "man_made_noise_db": -102.0,
    "environmental_noise_db": -105.0,
    "environment_type": "urban",
    "dominant_noise_source": "urban"
  }
}
```

### Position Updates

```json
{
  "type": "position_update",
  "timestamp": "2024-01-15T10:30:00Z",
  "data": {
    "latitude": 40.7128,
    "longitude": -74.0060,
    "altitude_m": 100.0,
    "maidenhead_locator": "FN20",
    "environment_type": "urban",
    "noise_floor_db": -95.0
  }
}
```

## Examples

### Python Client Example

```python
import requests
import json
import time

# Authentication
auth_response = requests.post('http://localhost:8080/auth/login', json={
    'username': 'pilot123',
    'password': 'secure_password',
    'client_type': 'flight_simulator'
})

token = auth_response.json()['token']
headers = {'Authorization': f'Bearer {token}'}

# Get noise floor status
status_response = requests.get('http://localhost:8080/api/v1/noise-floor/status', headers=headers)
noise_status = status_response.json()['noise_floor_status']
print(f"Current noise floor: {noise_status['current_noise_floor_db']} dB")
print(f"Environment type: {noise_status['environment_type']}")
print(f"Dominant noise source: {noise_status['dominant_noise_source']}")

# Set position via GPS
position_request = {
    'latitude': 40.7128,
    'longitude': -74.0060,
    'altitude_m': 100.0,
    'accuracy_m': 10.0
}

response = requests.post('http://localhost:8080/api/v1/noise-floor/position/gps',
                        headers=headers, json=position_request)
print(json.dumps(response.json(), indent=2))
```

### JavaScript WebSocket Example

```javascript
const ws = new WebSocket('ws://localhost:8080/ws');

ws.onopen = function() {
    console.log('Connected to Noise Floor WebSocket');
    
    // Subscribe to noise floor updates
    ws.send(JSON.stringify({
        type: 'subscribe',
        channel: 'noise_floor',
        vehicle_id: 'player_001'
    }));
};

ws.onmessage = function(event) {
    const data = JSON.parse(event.data);
    
    switch(data.type) {
        case 'noise_floor_update':
            console.log('Noise floor update:', data.data);
            break;
        case 'position_update':
            console.log('Position update:', data.data);
            break;
    }
};
```

This comprehensive Noise Floor Calculation system provides realistic atmospheric noise modeling with environment-specific calculations, distance-based noise falloff, and position management for enhanced radio communication simulation in FGCom-mumble.
